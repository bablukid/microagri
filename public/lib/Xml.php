<?php
/**
 * Generated by Haxe 4.0.0-rc.1+1fdd3d5
 */

use \php\Boot;
use \haxe\xml\Parser;
use \haxe\ds\StringMap;
use \php\_Boot\HxException;
use \haxe\xml\Printer;
use \php\_NativeIndexedArray\NativeIndexedArrayIterator;

/**
 * Cross-platform Xml API.
 * @see https://haxe.org/manual/std-Xml.html
 */
class Xml {
	/**
	 * @var int
	 * XML character data type.
	 */
	static public $CData;
	/**
	 * @var int
	 * XML comment type.
	 */
	static public $Comment;
	/**
	 * @var int
	 * XML doctype element type.
	 */
	static public $DocType;
	/**
	 * @var int
	 * XML document type.
	 */
	static public $Document;
	/**
	 * @var int
	 * XML element type.
	 */
	static public $Element;
	/**
	 * @var int
	 * XML parsed character data type.
	 */
	static public $PCData;
	/**
	 * @var int
	 * XML processing instruction type.
	 */
	static public $ProcessingInstruction;

	/**
	 * @var StringMap
	 */
	public $attributeMap;
	/**
	 * @var \Array_hx
	 */
	public $children;
	/**
	 * @var string
	 * Returns the node name of an Element.
	 */
	public $nodeName;
	/**
	 * @var int
	 * Returns the type of the Xml Node. This should be used before
	 * accessing other functions since some might raise an exception
	 * if the node type is not correct.
	 */
	public $nodeType;
	/**
	 * @var string
	 * Returns the node value. Only works if the Xml node is not an Element or a Document.
	 */
	public $nodeValue;
	/**
	 * @var Xml
	 * Returns the parent object in the Xml hierarchy.
	 * The parent can be `null`, an Element or a Document.
	 */
	public $parent;

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	static public function createCData ($data) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:177: characters 3-28
		$xml = new Xml(Xml::$CData);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:178: characters 3-23
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw new HxException("Bad node type, unexpected " . ($xml->nodeType??'null'));
		}
		$xml->nodeValue = $data;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:179: characters 3-13
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	static public function createComment ($data) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:186: characters 3-30
		$xml = new Xml(Xml::$Comment);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:187: characters 3-23
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw new HxException("Bad node type, unexpected " . ($xml->nodeType??'null'));
		}
		$xml->nodeValue = $data;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:188: characters 3-13
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	static public function createDocType ($data) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:195: characters 3-30
		$xml = new Xml(Xml::$DocType);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:196: characters 3-23
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw new HxException("Bad node type, unexpected " . ($xml->nodeType??'null'));
		}
		$xml->nodeValue = $data;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:197: characters 3-13
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @return Xml
	 */
	static public function createDocument () {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:213: characters 3-27
		return new Xml(Xml::$Document);
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $name
	 * 
	 * @return Xml
	 */
	static public function createElement ($name) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:159: characters 3-30
		$xml = new Xml(Xml::$Element);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:160: characters 3-22
		if ($xml->nodeType !== Xml::$Element) {
			throw new HxException("Bad node type, expected Element but found " . ($xml->nodeType??'null'));
		}
		$xml->nodeName = $name;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:161: characters 3-13
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	static public function createPCData ($data) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:168: characters 3-29
		$xml = new Xml(Xml::$PCData);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:169: characters 3-23
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw new HxException("Bad node type, unexpected " . ($xml->nodeType??'null'));
		}
		$xml->nodeValue = $data;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:170: characters 3-13
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	static public function createProcessingInstruction ($data) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:204: characters 3-44
		$xml = new Xml(Xml::$ProcessingInstruction);
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:205: characters 3-23
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw new HxException("Bad node type, unexpected " . ($xml->nodeType??'null'));
		}
		$xml->nodeValue = $data;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:206: characters 3-13
		return $xml;
	}

	/**
	 * Parses the String into an Xml document.
	 * 
	 * @param string $str
	 * 
	 * @return Xml
	 */
	static public function parse ($str) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:98: characters 3-36
		return Parser::parse($str);
	}

	/**
	 * @param int $nodeType
	 * 
	 * @return void
	 */
	public function __construct ($nodeType) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:371: characters 3-27
		$this->nodeType = $nodeType;
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:372: characters 3-16
		$this->children = new \Array_hx();
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:373: characters 3-27
		$this->attributeMap = new StringMap();
	}

	/**
	 * Adds a child node to the Document or Element.
	 * A child node can only be inside one given parent node, which is indicated by the `parent` property.
	 * If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
	 * If the child node was previously inside a different node, it will be moved to this Document or Element.
	 * 
	 * @param Xml $x
	 * 
	 * @return void
	 */
	public function addChild ($x) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:327: characters 3-22
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw new HxException("Bad node type, expected Element or Document but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:328: lines 328-330
		if ($x->parent !== null) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:329: characters 4-27
			$x->parent->removeChild($x);
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:331: characters 3-19
		$_this = $this->children;
		$_this->arr[$_this->length] = $x;
		++$_this->length;

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:332: characters 3-18
		$x->parent = $this;
	}

	/**
	 * Returns an `Iterator` on all the attribute names.
	 * 
	 * @return object
	 */
	public function attributes () {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:264: lines 264-266
		if ($this->nodeType !== Xml::$Element) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:265: characters 4-9
			throw new HxException("Bad node type, expected Element but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:267: characters 10-29
		return new NativeIndexedArrayIterator(array_map("strval", array_keys($this->attributeMap->data)));
	}

	/**
	 * Tells if the Element node has a given attribute.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * 
	 * @return bool
	 */
	public function exists ($att) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:254: lines 254-256
		if ($this->nodeType !== Xml::$Element) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:255: characters 4-9
			throw new HxException("Bad node type, expected Element but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:257: characters 10-34
		return array_key_exists($att, $this->attributeMap->data);
	}

	/**
	 * Returns the first child node which is an Element.
	 * 
	 * @return Xml
	 */
	public function firstElement () {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:311: characters 3-22
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw new HxException("Bad node type, expected Element or Document but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:312: lines 312-316
		$_g = 0;
		$_g1 = $this->children;
		while ($_g < $_g1->length) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:312: characters 8-13
			$child = ($_g1->arr[$_g] ?? null);
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:312: lines 312-316
			++$_g;
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:313: lines 313-315
			if ($child->nodeType === Xml::$Element) {
				#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:314: characters 5-17
				return $child;
			}
		}

		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:317: characters 3-14
		return null;
	}

	/**
	 * Get the given attribute of an Element node. Returns `null` if not found.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * 
	 * @return string
	 */
	public function get ($att) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:221: lines 221-223
		if ($this->nodeType !== Xml::$Element) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:222: characters 4-9
			throw new HxException("Bad node type, expected Element but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:224: characters 10-27
		return ($this->attributeMap->data[$att] ?? null);
	}

	/**
	 * Removes a child from the Document or Element.
	 * Returns true if the child was successfuly removed.
	 * 
	 * @param Xml $x
	 * 
	 * @return bool
	 */
	public function removeChild ($x) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:340: characters 3-22
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw new HxException("Bad node type, expected Element or Document but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:341: lines 341-344
		if ($this->children->remove($x)) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:342: characters 4-19
			$x->parent = null;
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:343: characters 4-15
			return true;
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:345: characters 3-15
		return false;
	}

	/**
	 * Set the given attribute value for an Element node.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * @param string $value
	 * 
	 * @return void
	 */
	public function set ($att, $value) {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:232: lines 232-234
		if ($this->nodeType !== Xml::$Element) {
			#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:233: characters 4-9
			throw new HxException("Bad node type, expected Element but found " . ($this->nodeType??'null'));
		}
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:235: characters 3-31
		$this->attributeMap->data[$att] = $value;
	}

	/**
	 * Returns a String representation of the Xml node.
	 * 
	 * @return string
	 */
	public function toString () {
		#/home/bubar/haxe/versions/4.0.0-rc.1/std/Xml.hx:367: characters 3-38
		return Printer::print($this);
	}

	public function __toString() {
		return $this->toString();
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$Element = 0;
		self::$PCData = 1;
		self::$CData = 2;
		self::$Comment = 3;
		self::$DocType = 4;
		self::$ProcessingInstruction = 5;
		self::$Document = 6;
	}
}

Boot::registerClass(Xml::class, 'Xml');
Xml::__hx__init();
